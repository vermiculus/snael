#+Title: SNAEL: A Super-Slow Social Network Analyser for English Literature
#+Author: Sean Allred
#+Date: [2013-04-20 Sat]

#+BEGIN_SRC python :tangle "./src/snael.py"
  print "Welcome to SNAEL, version 0.2"
#+END_SRC

* What are we Studying?
We are studying the social networks within a text stored in the
following file, served from [[http://fileserver.booktrust.org.uk/usr/library/documents/bbc-nssa-2009/other_peoples_gods.pdf][BookTrust.org]] on [2013-04-08 Mon].  The
file has been edited from its original form, but the text has not been
altered.

The work is entitled /Other People's Gods/ and was written by Naomi
Alderman, winning the 2009 BBC National Short Story Award, and is
freely available online.

#+BEGIN_SRC python :tangle "./src/snael.py"
  FILE_NAME = '../text/simple.txt'
#+END_SRC

* Wait, what is a Network?
A network is a graph---it is a collection of entities (usually called
'nodes') that are connected to each other in certain ways.

For the purposes of this research, the following =Network= class
defines a consistent interface for accumulating a weighted graph.

A =Network= has exactly one field, a dictionary of associations.  The
dictionary uses entities (must be hashable, e.g. strings) as keys and
one more dictionary as values.  This inner dictionary maps entities
onto weights.  Care has been taken to ensure that new entities are
appropriately handled and connections are two-way (adding a connection
from A->B is the same as adding a connection from B->A).
#+BEGIN_SRC python :tangle "./src/snael.py"
  class Network:
      def __init__(self):
          self.associations = dict()
      def addConnection(self, entityA, entityB):
          if entityA not in self.associations:
              self.associations[entityA]=dict()
          if entityB not in self.associations:
              self.associations[entityB]=dict()
  
          if entityA not in self.associations[entityB]:
              self.associations[entityB][entityA] = 0
          if entityB not in self.associations[entityA]:
              self.associations[entityA][entityB] = 0
  
          self.associations[entityA][entityB] += 1
          self.associations[entityB][entityA] += 1
#+END_SRC

* Load Text
Obviously, the first thing of significance we do is load the file into
memory.  This snippet of code opens =FILE_NAME= as read-only and loads
the full contents into =raw=.
#+BEGIN_SRC python :tangle "./src/snael.py"
  with open(FILE_NAME, 'r') as f:
      print '>reading file'
      raw = ''.join(f.readlines())
      print '>file read'
#+END_SRC

* Tokenize Text
#+BEGIN_SRC python :tangle "./src/snael.py"
  print '>importing nltk'
  import nltk
  print '>tokenizing'
  tokens = nltk.sent_tokenize(raw)
  tokens = [t.replace('\n',' ').replace('  ',' ') \
            for t in tokens if t is not '.']
  
  print '>converting to nltk.Text'
  text = nltk.Text(tokens)
#+END_SRC

* Create List of Names
We need to make sure that we have a list of all names.  Let's just
create a pipeline to tokenize, tag, and chunk a text:

#+BEGIN_SRC python :tangle "./src/snael.py"
  entities = lambda text: nltk.ne_chunk(nltk.pos_tag(nltk.word_tokenize(text)))
#+END_SRC

#+BEGIN_SRC python :tangle "./src/snael.py"
  names = ['Fabantou', 'Leblanc', 'Jondrette']
  #  text  = list() #of sentences, lines, or whatever

  def list2dict(l,dv=set()):
      d=dict()
      for e in l:
          d[e]=dv
      return d
#+END_SRC

* Resolve Anaphora (antecedents)

* Find Occurances
First we need to prepare a data structure for the occurances to live
in.  The obvious choice is a dictionary, with names as keys and lists
of locations as values.  So, to create this dictionary:

#+BEGIN_SRC python :tangle "./src/snael.py"
  occurances = dict()
  for name in names:
      occurances[name] = list()
#+END_SRC

Now find occurances and store them.

#+BEGIN_SRC python :tangle "./src/snael.py"
  for name in occurances.keys():
      for sentence in text:
          if name in sentence:
              names[name].append(text.index(sentence))
#+END_SRC
